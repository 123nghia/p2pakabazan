// package com.akabazan.controller;
// import com.akabazan.service;
// import com.akabazan.constant.ErrorCode;
// import com.akabazan.repository.UserRepository;
// import ch.qos.logback.core.spi.ErrorCodes;
// import com.akabazan.exception.ApplicationException;
// import io.jsonwebtoken.Jwts;
// import io.jsonwebtoken.SignatureAlgorithm;
// import jakarta.validation.Valid;
// import jakarta.validation.constraints.*;
// import org.springframework.http.ResponseEntity;
// import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
// import org.springframework.security.core.context.SecurityContextHolder;
// import org.springframework.web.bind.annotation.*;
// import java.util.Date;
// import javax.crypto.SecretKey;


// @RestController
// @RequestMapping("/auth")
// public class AuthController {
//     private final UserService userRepository;
//     private final SecretKey secretKey;

//     public AuthController(UserService userRepository, SecretKey secretKey) {
//         this.userRepository = userRepository;
//         this.secretKey = secretKey;
//     }

//     @PostMapping("/login")
//     public ResponseEntity<String> login( @RequestBody LoginRequest request) {
//         User user = userRepository.findByEmail(request.getEmail())
//                 .orElseThrow(() -> new ApplicationException(
//                     ErrorCode.USER_NOT_FOUND
//                 ));

//         if (!user.getPassword().equals(request.getPassword())) {
//             throw new ApplicationException(ErrorCode.INVALID_CREDENTIALS);
//         }
//         UsernamePasswordAuthenticationToken auth =
//                 new UsernamePasswordAuthenticationToken(user.getId().toString(), null, null);
//         SecurityContextHolder.getContext().setAuthentication(auth);
//         String token = Jwts.builder()
//                 .setSubject(user.getId().toString())
//                 .setIssuedAt(new Date())
//                 .setExpiration(new Date(System.currentTimeMillis() + 86400000L)) // 1 ngày
//                 .signWith(secretKey, SignatureAlgorithm.HS256)  // ✅ fix ở đây
//                 .compact();
//         return ResponseEntity.ok(token);
//     }
// }

// class LoginRequest {
//     @NotBlank(message = "Email is required")
//     @Email(message = "Invalid email format")
//     private String email;
//     @NotBlank(message = "Password is required")
//     private String password;
//     public String getEmail() { return email; }
//     public void setEmail(String email) { this.email = email; }
//     public String getPassword() { return password; }
//     public void setPassword(String password) { this.password = password; }
// }